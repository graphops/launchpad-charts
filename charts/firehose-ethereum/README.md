# Firehose-Ethereum Helm Chart

Deploy and scale all components of [Firehose EVM](https://github.com/streamingfast/firehose-ethereum) inside Kubernetes with ease

[![License](https://img.shields.io/badge/License-Apache%202.0-blue.svg)](https://opensource.org/licenses/Apache-2.0) ![Version: 0.1.0-canary.12](https://img.shields.io/badge/Version-0.1.0--canary.12-informational?style=flat-square) ![Type: application](https://img.shields.io/badge/Type-application-informational?style=flat-square) ![AppVersion: v2.11.1](https://img.shields.io/badge/AppVersion-v2.11.1-informational?style=flat-square)

## Introduction

Firehose is a high-performance blockchain data extraction tool that captures, processes, and streams blockchain data in real-time, enabling efficient data analysis and integration for various applications.

This chart can be used to deploy the constellation of services required to operate any [Firehose EVM](https://github.com/streamingfast/firehose-ethereum) chain.

## Chart Features

- Actively maintained by [GraphOps](https://graphops.xyz) [and contributors](https://github.com/graphops/launchpad-charts/graphs/contributors)
- Extreme flexibility and customizability
- Sane defaults with solid security parameters (non-root execution, ready-only root filesystem, drops all capabilities)
- Support for `ServiceMonitor`s to configure Prometheus to scrape metrics ([prometheus-operator](https://github.com/prometheus-operator/prometheus-operator))

## Chart Structure and Customization

This chart is focused on the [firehose-ethereum](https://github.com/streamingfast/firehose-ethereum) workload and allows setting up a variable number of workload instances (Deployments / StatefulSets) running it. That is defined in the top-level key `firehoseComponents`.

### firehoseComponents

Each of the sub-keys defined here will generate a workload (either a `Deployment` or `StatefulSet`, set with the `kind` key) with a particular configuration defined under the sub-key. The specific per-component definitions will be merged on top of the `firehoseComponentDefaults` top-level key, so all components inherit a common set of default configurations.

These instances will by default run `firehose-ethereum`, which will be configured via a ConfigMap which is dynamically generated with a combination of your values, the defaults, and templating. This configuration is set under the `.fireeth.config` subkeys, and will define the configuration parameters. Additionally, the set of firehose services to be launched by `firehose-ethereum` on a particular workload can be set under `.fireeth.services`.

Example:
```yaml
firehoseComponents:
  write-path-workload:
    kind: StatefulSet
    fireeth:
      services:
        - reader-node
        - index-builder
        - merger
      config:
        reader-node-grpc-listen-addr: "0.0.0.0:10010"
        index-builder-grpc-listen-addr: "0.0.0.0:10009"
  read-path-workload:
    kind: Deployment
    fireeth:
      services:
        - relayer
        - firehose
      config:
        merger-grpc-listen-addr: ":10012"
        firehose-grpc-listen-addr: "0.0.0.0:10015"
```

Will provision a Deployment, called `read-path-workload` and a StatefulSet called `write-path-workload`, each with its own ConfigMap dynamically generated based on that list of parameters, as well as a range of other Kubernetes resources such as a Service, Service Account, serviceMonitor, etc.

### firehoseServiceDefaults

All components defined in `firehoseComponents` inherit the `firehoseComponentDefaults`, and can be set to run arbitrary firehose services. As such, there is `firehoseServiceDefaults`, a top-level key which contains service-specific defaults. These get inherited by each component as a function of the services they define in their `.fireeth.services` list.

Example:

```yaml
firehoseComponentDefaults:
  kind: Deployment
  fireeth:
    config:
      firehose-rate-limit-bucket-size: 20
      firehose-rate-limit-bucket-fill-rate: "1s"

firehoseServiceDefaults:
  reader-node:
    kind: StatefulSet
    fireeth:
      config:
        reader-node-data-dir: "/var/lib/geth"

  merger:
    fireeth:
      config:
        merger-grpc-listen-addr: ":10012"

firehoseComponents:
  myComponent:
    fireeth:
      services:
        - merger
        - reader-node
      config:
        my-particular-option: "something"
        firehose-rate-limit-bucket-fill-rate: "5s"
```

This will result in a component with a combined configuration equivalent to:
```yaml
firehoseComponents:
  myComponent:
    kind: StatefulSet
    fireeth:
      services:
        - merger
        - reader-node
      config:
        firehose-rate-limit-bucket-size: 20
        firehose-rate-limit-bucket-fill-rate: "5s"
        reader-node-data-dir: "/var/lib/geth"
        merger-grpc-listen-addr: ":10012"
        my-particular-option: "something"
```

which will result in a StatefulSet with firehose running both merger and reader-node services on the POD instances.

*Note:* The firehoseServiceDefaults of each of the configured services will be merged in the order they are defined in the list, in this case reader-node defaults would be merged on top of merger. I.e., if merger had in its `firehoseServiceDefaults` an explicit `kind: Deployment`, then as is, we would still get a `StatefulSet`, but if we exchanged their order to:
```yaml
firehoseComponents:
  myComponent:
    fireeth:
      services:
        - reader-node
        - merger
```
then the result would be `kind: Deployment`. So it's intended for most of `firehoseServiceDefaults` to be component specific and do not overlap much with each other.

### General chart interfaces

Virtually any aspect of the workload (StatefulSet or Deployment) can be overriden under the component level key, where you can set things such as `resources:`, `nodeSelector:`, `podSecurityContext:`, `env:` or `labels:`. Note that those often map to keys that are structured in different parts of the workload spec, such as `metadata.labels` or keys from the POD level or the container definition (there is a single main container defined). In general those have been flattened for convenience.

On par with settings workload spec parameters, a firehose component includes a range of different resources such as a Service, ConfigMap, ServiceMonitor, .... Those resources have a corresponding key to override or extend their parameters, or with entra configuration settingsm, as well as an `enabled` boolean to toggle their creation. Example:

```yaml
# -- ServiceMonitor configuration for Prometheus Operator
serviceMonitor:
  # -- Enable monitoring by creating `ServiceMonitor` CRDs ([prometheus-operator](https://github.com/prometheus-operator/prometheus-operator))
  enabled: true
  metadata:
    labels: {}
    annotations: {}
  spec:
    # Endpoint overrides, keyed by port name
    endpoints:
      metrics-fh:
        # Override or add any endpoint-specific fields
        interval: "30s"
        scrapeTimeout: "10s"
        path: /metrics
        honorLabels: true
        # ... any other endpoint-specific fields
    # Any other top-level ServiceMonitor spec fields

  # -- Service account configuration
serviceAccount:
  # -- Specifies whether a service account should be created
  create: true
  # -- The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""
  # -- Annotations to add to the service account
  annotations: {}
  # -- Labels to add to the service account
  labels: {}
  rbac:
    create: true
    rules: []
    clusterWide: false
```

## Quickstart

To install the chart with the release name `my-release`:

```console
helm repo add graphops http://graphops.github.io/launchpad-charts
helm install my-release graphops/firehose-ethereum
```

## Upgrading

We recommend that you pin the version of the Chart that you deploy. You can use the `--version` flag with `helm install` and `helm upgrade` to specify a chart version constraint.

This project uses [Semantic Versioning](https://semver.org/). Changes to the version of the application (the `appVersion`) that the Chart deploys will generally result in a patch version bump for the Chart. Breaking changes to the Chart or its `values.yaml` interface will be reflected with a major version bump.

We do not recommend that you upgrade the application by overriding `image.tag`. Instead, use the version of the Chart that is built for your desired `appVersion`.

## Requirements

| Repository | Name | Version |
|------------|------|---------|
| https://graphops.github.io/launchpad-charts/canary | common | 0.0.1-canary.2 |

## Values

| Key | Description | Type | Default |
|-----|-------------|------|---------|
 | firehoseComponentDefaults.__enabled |  | bool | `true` |
 | firehoseComponentDefaults.clusterRole | Cluster scoped RBAC role and binding configuration Used by the P2P init-container | object | `{"__enabled":false,"metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"my-cluster-role"},"rules":[]}` |
 | firehoseComponentDefaults.clusterRoleBinding.__enabled |  | bool | `false` |
 | firehoseComponentDefaults.clusterRoleBinding.metadata.annotations |  | object | `{}` |
 | firehoseComponentDefaults.clusterRoleBinding.metadata.labels |  | string | `"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.clusterRoleBinding.metadata.name |  | string | `"{{ print \"%s-binding\" $roleName }} @needs(.Self.clusterRole.metadata.name as roleName)"` |
 | firehoseComponentDefaults.clusterRoleBinding.roleRef.apiGroup |  | string | `"rbac.authorization.k8s.io"` |
 | firehoseComponentDefaults.clusterRoleBinding.roleRef.kind |  | string | `"ClusterRole"` |
 | firehoseComponentDefaults.clusterRoleBinding.roleRef.name |  | string | `"{{ $roleName }} @needs(.Self.clusterRole.metadata.name as roleName)"` |
 | firehoseComponentDefaults.clusterRoleBinding.subjects.default.kind |  | string | `"ServiceAccount"` |
 | firehoseComponentDefaults.clusterRoleBinding.subjects.default.name |  | string | `"{{ $SAName }} @needs(.Self.serviceAccount.metadata.name as SAName)"` |
 | firehoseComponentDefaults.clusterRoleBinding.subjects.default.namespace |  | string | `"{{ .Root.Release.Namespace }}"` |
 | firehoseComponentDefaults.configMap | ConfigMap customization | object | `{"__enabled":true,"__options":{"useEnvSubst":false},"data":{"config.yaml":"{{- $hasServiceNode := false }}\nstart:\n  args:\n    {{- range $services }}\n    - {{ . }}\n    {{- if (contains \"node\" .) }}\n    {{- $hasServiceNode = true }}\n    {{- end }}\n    {{- end }}\n  flags:\n    {{- range $key, $value := $config }}\n    {{ $key }}: \"{{ $value }}\"\n    {{- end }}\n    {{- if $hasServiceNode }}\n    {{- $readerNodeArgs := include \"common.utils.generateArgsList\" (dict \"map\" ( $nodeArgs \| default dict ) \"orderList\" ( $nodeArgsOrder \| default list ) ) \| fromYamlArray }}\n    reader-node-arguments: \|\n      {{- range $readerNodeArgs }}\n      {{ . }}\n      {{- end }}\n      {{- end }}\n@needs(.Self.fireeth.services as services)\n@needs(.Self.fireeth.config as config)\n@needs(.Self.fireeth.nodeArgs as nodeArgs)\n@needs(.Self.fireeth.nodeArgsOrder as nodeArgsOrder)"},"metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ .Root.Release.Name }}-{{ .componentName }}-config"}}` |
 | firehoseComponentDefaults.configMap.__enabled | Create a ConfigMap (highly recommended) | bool | `true` |
 | firehoseComponentDefaults.configMap.__options | ConfigMap specific options | object | `{"useEnvSubst":false}` |
 | firehoseComponentDefaults.configMap.__options.useEnvSubst | Run an envsubst initcontainer at runtime | bool | `false` |
 | firehoseComponentDefaults.configMap.metadata | Any remaiing key/values can be added and will be merged with the templated ConfigMap resource | object | `{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ .Root.Release.Name }}-{{ .componentName }}-config"}` |
 | firehoseComponentDefaults.fireeth | Firehose-specific configuration | object | `{"args":{"--config-file":"/config/config.yaml","__separator":"=","start":"__none"},"argsOrder":["start","--config-file"],"config":{"common-auth-plugin":"null://","common-auto-max-procs":true,"common-auto-mem-limit-percent":95,"common-forked-blocks-store-url":null,"common-live-blocks-addr":"relayer:10014","common-merged-blocks-store-url":null,"common-one-block-store-url":null,"data-dir":"/var/lib/fireeth","firehose-rate-limit-bucket-fill-rate":"1s","firehose-rate-limit-bucket-size":20,"log-to-file":false,"metrics-listen-addr":"{{ $metrics.enabled \| ternary (printf \"%s:%d\" $metrics.addr ( $metrics.port \| int ) ) nil }}\n@needs(.Self.fireeth.metrics as metrics)\n","pprof-listen-addr":"{{ $pprof.enabled \| ternary (printf \"%s:%d\" $pprof.addr ($pprof.port \| int)) nil }} @needs(.Self.fireeth.pprof as pprof)","substreams-block-execution-timeout":"3m0s","substreams-rpc-endpoints":null,"substreams-rpc-gas-limit":"50000000","substreams-state-bundle-size":1000,"substreams-state-store-default-tag":"","substreams-state-store-url":null},"genesis-json":{"enabled":false},"jwt":{"enabled":false,"existingSecret":{"key":null,"name":null},"fromLiteral":null},"metrics":{"addr":"0.0.0.0","enabled":true,"port":9102},"nodeArgs":{},"nodeArgsOrder":[],"nodeMetrics":{"enabled":false},"p2p":{"enabled":false,"port":null},"pprof":{"addr":"127.0.0.1","enabled":true,"port":6060},"services":[]}` |
 | firehoseComponentDefaults.fireeth.args | Command line arguments for fireeth Generated from this map and format can be tweaked with __separator and __prefix. the '__none' string allows for declaring an argument without a value (i.e. --sepolia) | object | `{"--config-file":"/config/config.yaml","__separator":"=","start":"__none"}` |
 | firehoseComponentDefaults.fireeth.argsOrder | List to set a specific order for some of the args elements. The ones set will appear first in the order of the list, and the reamining ones will be unsorted, or alphabetically sorted | list | `["start","--config-file"]` |
 | firehoseComponentDefaults.fireeth.config | Fireeth configuration paramaters | object | `{"common-auth-plugin":"null://","common-auto-max-procs":true,"common-auto-mem-limit-percent":95,"common-forked-blocks-store-url":null,"common-live-blocks-addr":"relayer:10014","common-merged-blocks-store-url":null,"common-one-block-store-url":null,"data-dir":"/var/lib/fireeth","firehose-rate-limit-bucket-fill-rate":"1s","firehose-rate-limit-bucket-size":20,"log-to-file":false,"metrics-listen-addr":"{{ $metrics.enabled \| ternary (printf \"%s:%d\" $metrics.addr ( $metrics.port \| int ) ) nil }}\n@needs(.Self.fireeth.metrics as metrics)\n","pprof-listen-addr":"{{ $pprof.enabled \| ternary (printf \"%s:%d\" $pprof.addr ($pprof.port \| int)) nil }} @needs(.Self.fireeth.pprof as pprof)","substreams-block-execution-timeout":"3m0s","substreams-rpc-endpoints":null,"substreams-rpc-gas-limit":"50000000","substreams-state-bundle-size":1000,"substreams-state-store-default-tag":"","substreams-state-store-url":null}` |
 | firehoseComponentDefaults.fireeth.genesis-json.enabled | Add a genesis.json key to configMap | bool | `false` |
 | firehoseComponentDefaults.fireeth.jwt | Provision or use an existing JWT secret If it's enabled and neither existingSecret nor fromLiteral are set, a random secret will be generated and then re-used in the future | object | `{"enabled":false,"existingSecret":{"key":null,"name":null},"fromLiteral":null}` |
 | firehoseComponentDefaults.fireeth.jwt.enabled | Provision or make use of a JWT secret for Node | bool | `false` |
 | firehoseComponentDefaults.fireeth.jwt.existingSecret | Load the JWT from an existing Kubernetes Secret. Takes precedence over `fromLiteral` if set. | object | `{"key":null,"name":null}` |
 | firehoseComponentDefaults.fireeth.jwt.existingSecret.key | Data key for the JWT in the Secret | string | `nil` |
 | firehoseComponentDefaults.fireeth.jwt.existingSecret.name | Name of the Secret resource in the same namespace | string | `nil` |
 | firehoseComponentDefaults.fireeth.jwt.fromLiteral | Use this literal value for the JWT | string | `nil` |
 | firehoseComponentDefaults.fireeth.metrics | Enable support for metrics | object | `{"addr":"0.0.0.0","enabled":true,"port":9102}` |
 | firehoseComponentDefaults.fireeth.nodeArgs | Command line arguments to pass to the blockchain node | object | `{}` |
 | firehoseComponentDefaults.fireeth.nodeArgsOrder | List or ordered arguments for the nodeArgs | list | `[]` |
 | firehoseComponentDefaults.fireeth.nodeMetrics | Enable support for metrics on the blockchain node | object | `{"enabled":false}` |
 | firehoseComponentDefaults.fireeth.p2p | Enable a NodePort for P2P support in node | object | `{"enabled":false,"port":null}` |
 | firehoseComponentDefaults.fireeth.p2p.enabled | Expose P2P port via NodePort | bool | `false` |
 | firehoseComponentDefaults.fireeth.p2p.port | NodePort to be used. Must be unique. Leave blank for a dynamic port | string | `nil` |
 | firehoseComponentDefaults.fireeth.pprof | Enable pprof interface support for profiling data | object | `{"addr":"127.0.0.1","enabled":true,"port":6060}` |
 | firehoseComponentDefaults.fireeth.services | List of firehose services to launch (reader-node | merger | relayer | ...) | list | `[]` |
 | firehoseComponentDefaults.horizontalPodAutoscaler | HorizontalPodAutoscaler configuration | object | `{"__enabled":false,"metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"},"spec":{}}` |
 | firehoseComponentDefaults.horizontalPodAutoscaler.metadata | Anything else will be marge on the final horizonta.Self.utoscaler resource template | object | `{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"}` |
 | firehoseComponentDefaults.image | Image configuration for firehose-ethereum | object | `{"digest":"","pullPolicy":"IfNotPresent","repository":"ghcr.io/streamingfast/firehose-ethereum","tag":"v2.11.1-geth-v1.15.5-fh3.0 "}` |
 | firehoseComponentDefaults.image.digest | Overrides the image reference using a specific digest | string | `""` |
 | firehoseComponentDefaults.image.pullPolicy | Image pull policy | string | `"IfNotPresent"` |
 | firehoseComponentDefaults.image.repository | Docker image repository | string | `"ghcr.io/streamingfast/firehose-ethereum"` |
 | firehoseComponentDefaults.image.tag | Overrides the image reference using a tag digest takes precedence over tag if both are set | string | `"v2.11.1-geth-v1.15.5-fh3.0 "` |
 | firehoseComponentDefaults.imagePullSecrets | Pull secrets required to fetch images | list | `[]` |
 | firehoseComponentDefaults.podDisruptionBudget | .Self.Disruption Budget configuration | object | `{"__enabled":true,"metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ .Root.Release.Name }}-{{ .componentName }}"},"spec":{"selector":{"matchLabels":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"}}}}` |
 | firehoseComponentDefaults.role | RBAC role and binding configuration | object | `{"__enabled":"{{ $SAEnabled }} @needs(.Self.serviceAccount.__enabled as SAEnabled)","__name":"role","metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ printf \"%s-%s-%s\" .Root.Release.Name .componentName $roleName }} @needs(.Self.role.__name as roleName)"},"rules":[]}` |
 | firehoseComponentDefaults.roleBinding.__enabled |  | string | `"{{ $roleEnabled }} @needs(.Self.role.__enabled as roleEnabled)"` |
 | firehoseComponentDefaults.roleBinding.metadata.annotations |  | object | `{}` |
 | firehoseComponentDefaults.roleBinding.metadata.labels |  | string | `"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.roleBinding.metadata.name |  | string | `"{{ printf \"%s-%s-%s\" .Root.Release.Name .componentName $roleName }} @needs(.Self.role.__name as roleName)"` |
 | firehoseComponentDefaults.roleBinding.roleRef.apiGroup |  | string | `"rbac.authorization.k8s.io"` |
 | firehoseComponentDefaults.roleBinding.roleRef.kind |  | string | `"Role"` |
 | firehoseComponentDefaults.roleBinding.roleRef.name |  | string | `"{{ $roleName }} @needs(.Self.role.metadata.name as roleName)"` |
 | firehoseComponentDefaults.roleBinding.subjects[0].kind |  | string | `"ServiceAccount"` |
 | firehoseComponentDefaults.roleBinding.subjects[0].name |  | string | `"{{ $SAName }} @needs(.Self.serviceAccount.metadata.name as SAName)"` |
 | firehoseComponentDefaults.roleBinding.subjects[0].namespace |  | string | `"{{ .Root.Release.Namespace }}"` |
 | firehoseComponentDefaults.serviceAccount | Service account configuration | object | `{"__enabled":true,"metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ printf \"%s-%s\" (include \"common.metadata.fullname\" $) .componentName }}"}}` |
 | firehoseComponentDefaults.serviceAccount.__enabled | Specifies whether a service account should be created | bool | `true` |
 | firehoseComponentDefaults.serviceAccount.metadata | Rest spec | object | `{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ printf \"%s-%s\" (include \"common.metadata.fullname\" $) .componentName }}"}` |
 | firehoseComponentDefaults.serviceAccount.metadata.annotations | Annotations to add to the service account | object | `{}` |
 | firehoseComponentDefaults.serviceAccount.metadata.labels | Labels to add to the service account | string | `"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.serviceAccount.metadata.name | The name of the service account to use. If not set and create is true, a name is generated using the fullname template | string | `"{{ printf \"%s-%s\" (include \"common.metadata.fullname\" $) .componentName }}"` |
 | firehoseComponentDefaults.serviceMonitor | ServiceMonitor configuration for Prometheus Operator | object | `{"__enabled":true,"metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ printf \"%s-%s\" (include \"common.metadata.fullname\" $) .componentName }}"},"spec":{"endpoints":{"fh-metrics":{"honorLabels":true,"interval":"30s","path":"/metrics","scrapeTimeout":"10s"}},"jobLabel":"{{- .Root.Release.Name }}","selector":{"matchLabels":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"}}}}` |
 | firehoseComponentDefaults.serviceMonitor.__enabled | Enable monitoring by creating `ServiceMonitor` CRDs ([prometheus-operator](https://github.com/prometheus-operator/prometheus-operator)) | bool | `true` |
 | firehoseComponentDefaults.serviceName | Required for StatefulSets | string | `"{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-headless"` |
 | firehoseComponentDefaults.services | Service customization | object | `{"default":{"__enabled":true,"metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}"},"spec":{"ports":{"fh-metrics":{"port":"{{ $metrics.enabled \| ternary (printf \"%d\" ( $metrics.port \| int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)","protocol":"{{ $metrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.metrics as metrics)"},"fh-pprof":{"port":"{{ $pprof.enabled \| ternary (printf \"%d\" ( $pprof.port \| int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)","protocol":"{{ $pprof.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.pprof as pprof)"}},"selector":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"},"type":"ClusterIP"}},"headless":{"__enabled":"{{ eq $kind \"StatefulSet\" \| ternary true true }} @needs(.Self.workload.kind as kind)","metadata":{"annotations":{},"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-headless"},"spec":{"<<":{"ports":{"fh-metrics":{"port":"{{ $metrics.enabled \| ternary (printf \"%d\" ( $metrics.port \| int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)","protocol":"{{ $metrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.metrics as metrics)"},"fh-pprof":{"port":"{{ $pprof.enabled \| ternary (printf \"%d\" ( $pprof.port \| int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)","protocol":"{{ $pprof.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.pprof as pprof)"}},"selector":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"},"type":"ClusterIP"},"clusterIP":"None"}},"p2p":{"__enabled":"{{ default false $p2p.enabled }} @needs(.Self.fireeth.p2p as p2p)","metadata":{"annotations":{},"labels":"type: p2p\npod: '{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-0'\n{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-p2p"},"spec":{"ports":{"p2p-tcp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"TCP","targetPort":null},"p2p-udp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"UDP","targetPort":null}},"selector":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"},"type":"NodePort"}}}` |
 | firehoseComponentDefaults.services.default.__enabled | Create a Service | bool | `true` |
 | firehoseComponentDefaults.services.default.metadata.annotations | Additional service annotations | object | `{}` |
 | firehoseComponentDefaults.services.default.metadata.labels | Additional service labels | string | `"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.services.default.spec | Any other key/values will be merged with the final Service resource `spec.ports` is a key-value map, with the port name as key, and the spec as value | object | `{"ports":{"fh-metrics":{"port":"{{ $metrics.enabled \| ternary (printf \"%d\" ( $metrics.port \| int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)","protocol":"{{ $metrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.metrics as metrics)"},"fh-pprof":{"port":"{{ $pprof.enabled \| ternary (printf \"%d\" ( $pprof.port \| int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)","protocol":"{{ $pprof.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.pprof as pprof)"}},"selector":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"},"type":"ClusterIP"}` |
 | firehoseComponentDefaults.services.default.spec.ports | Service ports configuration | object | `{"fh-metrics":{"port":"{{ $metrics.enabled \| ternary (printf \"%d\" ( $metrics.port \| int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)","protocol":"{{ $metrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.metrics as metrics)"},"fh-pprof":{"port":"{{ $pprof.enabled \| ternary (printf \"%d\" ( $pprof.port \| int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)","protocol":"{{ $pprof.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.pprof as pprof)"}}` |
 | firehoseComponentDefaults.services.default.spec.type | Service type | string | `"ClusterIP"` |
 | firehoseComponentDefaults.services.headless.__enabled | Create headless services, mandatory for StatefulSets and true by default | string | `"{{ eq $kind \"StatefulSet\" \| ternary true true }} @needs(.Self.workload.kind as kind)"` |
 | firehoseComponentDefaults.services.headless.metadata.annotations | Additional service annotations | object | `{}` |
 | firehoseComponentDefaults.services.headless.metadata.labels | Additional service labels | string | `"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.services.headless.spec | Any other key/values will be merged with the final Service resource `spec.ports` is a key-value map, with the port name as key, and the spec as value | object | `{"<<":{"ports":{"fh-metrics":{"port":"{{ $metrics.enabled \| ternary (printf \"%d\" ( $metrics.port \| int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)","protocol":"{{ $metrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.metrics as metrics)"},"fh-pprof":{"port":"{{ $pprof.enabled \| ternary (printf \"%d\" ( $pprof.port \| int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)","protocol":"{{ $pprof.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.pprof as pprof)"}},"selector":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"},"type":"ClusterIP"},"clusterIP":"None"}` |
 | firehoseComponentDefaults.services.headless.spec.<<.ports | Service ports configuration | object | `{"fh-metrics":{"port":"{{ $metrics.enabled \| ternary (printf \"%d\" ( $metrics.port \| int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)","protocol":"{{ $metrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.metrics as metrics)"},"fh-pprof":{"port":"{{ $pprof.enabled \| ternary (printf \"%d\" ( $pprof.port \| int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)","protocol":"{{ $pprof.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.pprof as pprof)"}}` |
 | firehoseComponentDefaults.services.headless.spec.<<.type | Service type | string | `"ClusterIP"` |
 | firehoseComponentDefaults.services.p2p | Creates a NodePort service (used in P2P support) if a nodePort isn't specified, kubernetes will dinamically attribute one | object | `{"__enabled":"{{ default false $p2p.enabled }} @needs(.Self.fireeth.p2p as p2p)","metadata":{"annotations":{},"labels":"type: p2p\npod: '{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-0'\n{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-p2p"},"spec":{"ports":{"p2p-tcp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"TCP","targetPort":null},"p2p-udp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"UDP","targetPort":null}},"selector":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"},"type":"NodePort"}}` |
 | firehoseComponentDefaults.services.p2p.metadata.annotations | Additional service annotations | object | `{}` |
 | firehoseComponentDefaults.services.p2p.metadata.labels | Additional service labels | string | `"type: p2p\npod: '{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-0'\n{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.services.p2p.spec | Any other key/values will be merged with the final Service resource `spec.ports` is a key-value map, with the port name as key, and the spec as value | object | `{"ports":{"p2p-tcp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"TCP","targetPort":null},"p2p-udp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"UDP","targetPort":null}},"selector":{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}"},"type":"NodePort"}` |
 | firehoseComponentDefaults.services.p2p.spec.ports | Service ports configuration | object | `{"p2p-tcp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"TCP","targetPort":null},"p2p-udp":{"nodePort":null,"port":"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)","protocol":"UDP","targetPort":null}}` |
 | firehoseComponentDefaults.services.p2p.spec.ports.p2p-tcp.nodePort | nodePort to use, if left null a dynamic one will be atributed | optional | `nil` |
 | firehoseComponentDefaults.services.p2p.spec.ports.p2p-tcp.port | default is to use nodePort if specified, or 30303 | mandatory | `"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)"` |
 | firehoseComponentDefaults.services.p2p.spec.ports.p2p-tcp.targetPort | default is to use the port's name | optional | `nil` |
 | firehoseComponentDefaults.services.p2p.spec.ports.p2p-udp.nodePort | nodePort to use, if left null a dynamic one will be atributed | optional | `nil` |
 | firehoseComponentDefaults.services.p2p.spec.ports.p2p-udp.port | default is to use nodePort if specified, or 30303 | mandatory | `"{{ default (30303 \| int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)"` |
 | firehoseComponentDefaults.services.p2p.spec.ports.p2p-udp.targetPort | default is to use the port's name | optional | `nil` |
 | firehoseComponentDefaults.workload.__enabled |  | bool | `true` |
 | firehoseComponentDefaults.workload.kind | Default workload type (Deployment | StatefulSet) | string | `"Deployment"` |
 | firehoseComponentDefaults.workload.metadata.annotations | Component level annotations (templated) | object | `{}` |
 | firehoseComponentDefaults.workload.metadata.labels | Component level labels (templated) | string | `"app.kubernetes.io/component: '{{ .componentName }}'\napp.kubernetes.io/part-of: '{{ .Root.Release.Name }}'\n{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.workload.metadata.name |  | string | `"{{ printf \"%s-%s\" (include \"common.metadata.fullname\" $) .componentName }}"` |
 | firehoseComponentDefaults.workload.spec.podManagementPolicy | , scaling behavior: (OrderedReady | Parallel) | StatefulSet only | `"{{ eq $kind \"StatefulSet\" \| ternary \"OrderedReady\" nil }} @needs(.Self.workload.kind as kind)"` |
 | firehoseComponentDefaults.workload.spec.selector.matchLabels."app.kubernetes.io/component" |  | string | `"{{ .componentName }}"` |
 | firehoseComponentDefaults.workload.spec.selector.matchLabels."app.kubernetes.io/instance" |  | string | `"{{ .Root.Release.Name }}"` |
 | firehoseComponentDefaults.workload.spec.selector.matchLabels."app.kubernetes.io/name" |  | string | `"{{ .Root.Chart.Name }}"` |
 | firehoseComponentDefaults.workload.spec.template.metadata.labels |  | string | `"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)"` |
 | firehoseComponentDefaults.workload.spec.template.spec.affinity | Affinity configuration | object | `{}` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.args |  | string | `"{{- $argsList := include \"common.utils.generateArgsList\" (dict \"map\" ( $args \| default dict ) \"orderList\" ( $argsOrder \| default list ) ) \| fromYamlArray }}\n{{ $argsList \| toYaml }}\n@needs(.Self.fireeth.args as args)\n@needs(.Self.fireeth.argsOrder as argsOrder)\n@type(yamlArray)\n"` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.command | Container entrypoint | list | `["/app/fireeth"]` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.env | Environment variables | object | `{"POD_NAME":{"valueFrom":{"fieldRef":{"fieldPath":"metadata.name"}}}}` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.image |  | string | `"{{ printf \"%s:%s\" $repository $tag }} @needs(.Self.image.repository as repository) @needs(.Self.image.tag as tag)"` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.imagePullPolicy |  | string | `"IfNotPresent"` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.lifecycle | Lifecycle hooks | object | `{}` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.ports | Container level ports configuration | object | `{"fh-metrics":{"containerPort":"{{ $metrics.enabled \| ternary (printf \"%d\" ( $metrics.port \| int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)","protocol":"TCP"},"fh-pprof":{"containerPort":"{{ $pprof.enabled \| ternary (printf \"%d\" ( $pprof.port \| int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)","protocol":"TCP"}}` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.resources | Resource requests and limits | object | `{}` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.securityContext | Container level security context overrides | object | `{"allowPrivilegeEscalation":false,"capabilities":{"drop":["ALL"]},"readOnlyRootFilesystem":true}` |
 | firehoseComponentDefaults.workload.spec.template.spec.containers.fireeth.volumeMounts | Container volumeMounts | object | `{"config":{"__enabled":"{{ $configMapEnabled }} @needs(.Self.configMap.__enabled as configMapEnabled)","mountPath":"{{ $useEnvSubst \| ternary \"/config-input\" \"/config\" }} @needs(.Self.configMap.__options.useEnvSubst as useEnvSubst)","readOnly":true},"config-processed":{"__enabled":"{{ $useEnvSubst }} @needs(.Self.configMap.__options.useEnvSubst as useEnvSubst)","mountPath":"/config","readOnly":false},"data-dir":{"__enabled":true,"mountPath":"{{ index $config \"data-dir\" }} @needs(.Self.fireeth.config as config)","readOnly":false}}` |
 | firehoseComponentDefaults.workload.spec.template.spec.initContainers | Init containers configuration | object | `{"10-init-nodeport@common":{"__enabled":"{{ $p2p.enabled }} @needs(.Self.fireeth.p2p as p2p)","image":"ghcr.io/graphops/docker-builds/init-toolbox:main","imagePullPolicy":"IfNotPresent","resources":{}},"20-init-envsubst@common":{"__enabled":"{{ $configMapOpt.useEnvSubst }} @needs(.Self.configMap.__options as configMapOpt)","image":"blockstack/envsubst:latest","imagePullPolicy":"IfNotPresent","resources":{}}}` |
 | firehoseComponentDefaults.workload.spec.template.spec.nodeSelector | Node selector configuration | object | `{}` |
 | firehoseComponentDefaults.workload.spec.template.spec.securityContext | .Self.wide security context | object | `{"fsGroup":"{{ $runAsUser }} @needs(.Self.workload.spec.template.spec.securityContext.runAsUser as runAsUser)","runAsGroup":"{{ $runAsUser }} @needs(.Self.workload.spec.template.spec.securityContext.runAsUser as runAsUser)","runAsNonRoot":true,"runAsUser":1000}` |
 | firehoseComponentDefaults.workload.spec.template.spec.serviceAccountName |  | string | `"{{ $sa.__enabled \| ternary $sa.metadata.name nil }} @needs(.Self.serviceAccount as sa)"` |
 | firehoseComponentDefaults.workload.spec.template.spec.terminationGracePeriodSeconds | Amount of time to wait before force-killing the process | int | `10` |
 | firehoseComponentDefaults.workload.spec.template.spec.tolerations | Tolerations configuration | list | `[]` |
 | firehoseComponentDefaults.workload.spec.template.spec.topologySpreadConstraints | Topology spread constraints | list | `[]` |
 | firehoseComponentDefaults.workload.spec.template.spec.volumes | .Self.volumes | object | `{"config":{"__enabled":"{{ $configMapEnabled }} @needs(.Self.configMap.__enabled as configMapEnabled)","configMap":{"defaultMode":420,"name":"{{ $configMapName }} @needs(.Self.configMap.metadata.name as configMapName)"}},"config-processed":{"__enabled":"{{ and $configMap.__options.useEnvSubst $configMap.__enabled }} @needs(.Self.configMap as configMap)","emptyDir":{"medium":"Memory"}},"data-dir":{"__enabled":true,"emptyDir":{}},"env-dir":{"__enabled":"{{ (or (and $configMap.__options.useEnvSubst $configMap.__enabled) false ) \| ternary true false }} @needs(.Self.configMap as configMap)","emptyDir":{"medium":"Memory"}}}` |
 | firehoseComponentDefaults.workload.spec.updateStrategy | Update Strategy, (RollingUpdate | Recreate) for Deployments, (RollingUpdate | OnDelete) for StatefulSets | object | `{"__enabled":"{{- eq $kind \"StatefulSet\" }} @needs(.Self.workload.kind as kind)","type":"RollingUpdate"}` |
 | firehoseComponents | Definition and architecture of components to provision. A component is a kubernetes workload (Deployment or StatefulSet). The components will be named by the key name, and inherit the firehoseComponentDefaults as well as the defaults for the firehose services they will be set to run, under `.fireeth.services` list. For each component, configuraiton follows <firehoseComponentDefaults>. | object | `{"grpc":{"__enabled":true,"fireeth":{"services":["firehose"]}},"index-builder":{"__enabled":true,"fireeth":{"services":["index-builder"]}},"merger":{"__enabled":true,"fireeth":{"services":["merger"]}},"reader-node":{"__enabled":true,"fireeth":{"services":["reader-node"]}},"relayer":{"__enabled":true,"fireeth":{"services":["relayer"]}},"substreams-tier1":{"__enabled":true,"fireeth":{"services":["substreams-tier1"]}},"substreams-tier2":{"__enabled":true,"fireeth":{"services":["substreams-tier2"]}}}` |
 | firehoseServiceDefaults | Defaults per firehose service type, will get inherited by workloads running that service keys will match service names, and on each key the same interface as <firehoseDefaults> is available | object | `{"firehose":{"fireeth":{"config":{"firehose-grpc-listen-addr":"0.0.0.0:10015"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"fh-grpc":{"port":"{{ if (index $config \"firehose-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"firehose-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"fh-grpc":{"containerPort":"{{ if (index $config \"firehose-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"firehose-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n"}}}}}}}}},"index-builder":{"fireeth":{"config":{"index-builder-grpc-listen-addr":"0.0.0.0:10009","index-builder-index-size":"1000"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"index-grpc":{"port":"{{ if (index $config \"index-builder-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"index-builder-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"index-grpc":{"port":"{{ if (index $config \"index-builder-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"index-builder-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"index-grpc":{"containerPort":"{{ with .Self.fireeth.config }}{{ if (index . \"index-builder-grpc-listen-addr\") }}{{ splitList \":\" (index . \"index-builder-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}{{ end }}","protocol":"TCP"}}}}}}}}},"merger":{"fireeth":{"config":{"merger-grpc-listen-addr":":10012"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"merger-grpc":{"port":"{{ if (index $config \"merger-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"merger-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"merger-grpc":{"port":"{{ if (index $config \"merger-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"merger-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"merger-grpc":{"containerPort":"{{ if (index $config \"merger-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"merger-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}}}}}}},"reader-node":{"clusterRole":{"__enabled":"{{ $p2pEnabled }} @needs(.Self.fireeth.p2p.enabled as p2pEnabled)","rules":[{"apiGroups":[""],"resources":["nodes"],"verbs":["get","list","watch"]}]},"configMap":{"__enabled":true,"__options":{"useEnvSubst":true},"data":{"genesis.json":"{{ $genesisJson.enabled \| ternary ( $genesisJson.data \| toYaml \| nindent 8 ) nil }} @needs(.Self.fireeth[genesis-json] as genesisJson)\n"}},"fireeth":{"config":{"reader-node-bootstrap-data-url":"{{ $genesisJson.enabled \| ternary \"/genesis/genesis.json\" nil }} @needs(.Self.fireeth[genesis-json] as genesisJson)","reader-node-data-dir":"/var/lib/geth","reader-node-grpc-listen-addr":"0.0.0.0:10010","reader-node-manager-api-addr":"127.0.0.1:10011","reader-node-path":"/app/geth"},"genesis-json":{"data":{"genesis.json":"<JSON data>\n"},"enabled":false},"jwt":{"enabled":true},"nodeArgs":{"__prefix":"--","__separator":"=","authrpc.addr":"0.0.0.0","authrpc.jwtsecret":"{{ $jwt.enabled \| ternary \"/secrets/jwt/jwt.hex\" nil }} @needs(.Self.fireeth.jwt as jwt)","authrpc.port":8551,"authrpc.vhosts":"*","cache":8192,"datadir":"{node-data-dir}","discovery.port":"{{ $p2p.enabled \| ternary \"${EXTERNAL_PORT_P2P_TCP}\" nil }} @needs(.Self.fireeth.p2p as p2p)","history.transactions":1000,"http":"__none","http.addr":"0.0.0.0","http.api":"net,web3,eth,debug","http.port":8545,"http.vhosts":"*","maxpeers":100,"metrics.addr":"{{ $nodeMetrics.enabled \| ternary $nodeMetrics.addr nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","metrics.port":"{{ $nodeMetrics.enabled \| ternary ($nodeMetrics.port \| int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","nat":"{{ $p2p.enabled \| ternary \"extip:${EXTERNAL_IP}\" nil }} @needs(.Self.fireeth.p2p as p2p)","port":"{{ $p2p.enabled \| ternary \"${EXTERNAL_PORT_P2P_TCP}\" nil }} @needs(.Self.fireeth.p2p as p2p)","snapshot":"true","syncmode":"full","vmtrace":"firehose"},"nodeArgsOrder":[],"nodeMetrics":{"addr":"0.0.0.0","enabled":true,"port":6061},"p2p":{"enabled":true,"port":null}},"role":{"__enabled":true,"rules":[{"apiGroups":[""],"resources":["services"],"verbs":["get","list","watch"]},{"apiGroups":[""],"resources":["secrets"],"verbs":["get","create"]}]},"services":{"default":{"spec":{"ports":{"node-authrpc":{"port":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary (index $nodeArgs \"authrpc.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"node-metrics":{"port":"{{ $nodeMetrics.enabled \| ternary ($nodeMetrics.port \| int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","protocol":"{{ $nodeMetrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)"},"node-mgr":{"port":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary (splitList \":\" (index $config \"reader-node-manager-api-addr\") \| last) nil }} @needs(.Self.fireeth.config as config)","protocol":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.config as config)"},"node-rpc":{"port":"{{ hasKey $nodeArgs \"http.port\" \| ternary (index $nodeArgs \"http.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"http.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"reader-grpc":{"port":"{{ if (index $config \"reader-node-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"reader-node-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"spec":{"ports":{"node-authrpc":{"port":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary (index $nodeArgs \"authrpc.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"node-metrics":{"port":"{{ $nodeMetrics.enabled \| ternary ($nodeMetrics.port \| int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","protocol":"{{ $nodeMetrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)"},"node-mgr":{"port":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary (splitList \":\" (index $config \"reader-node-manager-api-addr\") \| last) nil }} @needs(.Self.fireeth.config as config)","protocol":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.config as config)"},"node-rpc":{"port":"{{ hasKey $nodeArgs \"http.port\" \| ternary (index $nodeArgs \"http.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"http.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"reader-grpc":{"port":"{{ if (index $config \"reader-node-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"reader-node-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"kind":"StatefulSet","spec":{"serviceName":"{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-headless","template":{"spec":{"containers":{"fireeth":{"env":{"MANAGER_API_PORT":{"value":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary (splitList \":\" (index $config \"reader-node-manager-api-addr\") \| last \| trimSuffix \"*\" \| int) nil }}\n@type(string)\n@needs(.Self.fireeth.config as config)\n"}},"lifecycle":{"preStop":{"exec":{"command":["/usr/local/bin/eth-maintenance"]}}},"ports":{"node-authrpc":{"containerPort":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary (index $nodeArgs \"authrpc.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"TCP"},"node-metrics":{"containerPort":"{{ if $nodeMetrics.port }}{{ $nodeMetrics.port \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","protocol":"TCP"},"node-mgr":{"containerPort":"{{ splitList \":\" ( index $config \"reader-node-manager-api-addr\" ) \| last \| int }} @needs(.Self.fireeth.config as config)","protocol":"TCP"},"node-rpc":{"containerPort":"{{ hasKey $nodeArgs \"http.port\" \| ternary (index $nodeArgs \"http.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"TCP"},"reader-grpc":{"containerPort":"{{ if (index $config \"reader-node-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"reader-node-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}},"volumeMounts":{"genesis-json":{"__enabled":"{{ $genesisJson.enabled \| default false }} @needs(.Self.fireeth[genesis-json] as genesisJson)","mountPath":"/genesis","readOnly":true,"subPath":"genesis.json"},"jwt-secret":{"__enabled":"{{ $jwt.enabled \| default false }} @needs(.Self.fireeth.jwt as jwt)","mountPath":"/secrets/jwt","readOnly":true},"node-data-dir":{"__enabled":true,"mountPath":"{{ index $config \"reader-node-data-dir\" }} @needs(.Self.fireeth.config as config)","readOnly":false}}}},"volumes":{"data-dir":{"emptyDir":null,"persistentVolumeClaim":{"claimName":"data-dir"}},"genesis-json":{"__enabled":"{{ $genesisJson.enabled \| default false }} @needs(.Self.fireeth[genesis-json] as genesisJson)","configMap":{"defaultMode":420,"items":[{"key":"genesis.json","path":"genesis.json"}],"name":"{{ $configMapName }} @needs(.Self.configMap.metadata.name as configMapName)"}},"jwt-secret":{"__enabled":"{{ .Self.fireeth.jwt.enabled \| default false }}","secret":{"items":[{"key":"{{ with .Self.fireeth.jwt }}{{ .existingSecret.key \| default \"jwt.hex\" }}{{ end }}","path":"jwt.hex"}],"secretName":"{{ with .Self.fireeth.jwt }}{{ .existingSecret.name \| default (printf \"%s-%s-jwt\" (include \"common.metadata.fullname\" $) $.componentName ) }}{{ end }}"}},"node-data-dir":{"__enabled":true,"persistentVolumeClaim":{"claimName":"node-data-dir"}}}}},"volumeClaimTemplates":{"data-dir":{"__enabled":true,"metadata":{"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"data-dir"},"spec":{"accessModes":["ReadWriteOnce"],"resources":{"requests":{"storage":"50Gi"}},"storageClassName":"openebs-zfs-localpv-compressed-8k"}},"node-data-dir":{"__enabled":true,"metadata":{"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"node-data-dir"},"spec":{"accessModes":["ReadWriteOnce"],"resources":{"requests":{"storage":"3Ti"}},"storageClassName":"openebs-zfs-localpv-compressed-8k"}}}}}},"relayer":{"fireeth":{"config":{"relayer-grpc-listen-addr":"0.0.0.0:10014","relayer-max-source-latency":"1h","relayer-source":"firehose-ethereum-1-reader:10010"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"relayer-grpc":{"port":"{{ if (index $config \"relayer-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"relayer-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"relayer-grpc":{"port":"{{ if (index $config \"relayer-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"relayer-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"relayer-grpc":{"containerPort":"{{ if (index $config \"relayer-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"relayer-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}}}}},"substreams-tier1":{"fireeth":{"config":{"substreams-tier1-active-requests-hard-limit":0,"substreams-tier1-active-requests-soft-limit":4,"substreams-tier1-enforce-compression":true,"substreams-tier1-grpc-listen-addr":":10016","substreams-tier1-max-subrequests":4,"substreams-tier1-subrequests-endpoint":"{{- $port := \"\" }}\n{{- if (index $tier2Config \"substreams-tier2-grpc-listen-addr\") }}\n  {{- $port = splitList \":\" (index $tier2Config \"substreams-tier2-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}\n{{- else }}\n  {{- $port = \"\" }}\n{{- end }}\n{{- if not (empty $port) }}{{ printf \"%s-%s:%d\" .Root.Release.Name \"substreams-tier2\" $port }}{{ else }}null{{ end }}\n@needs(.ComponentValues.substreams-tier2.fireeth.config as tier2Config)\n","substreams-tier1-subrequests-plaintext":true}},"services":{"default":{"__enabled":true,"spec":{"ports":{"tier1-grpc":{"port":"{{ if (index $config \"substreams-tier1-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"substreams-tier1-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"},"tier1-subreq":{"port":"{{ if (index $config \"substreams-tier1-subrequests-endpoint\") }}{{ splitList \":\" (index $config \"substreams-tier1-subrequests-endpoint\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"tier1-grpc":{"port":"{{ if (index $config \"substreams-tier1-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"substreams-tier1-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"},"tier1-subreq":{"port":"{{ if (index $config \"substreams-tier1-subrequests-endpoint\") }}{{ splitList \":\" (index $config \"substreams-tier1-subrequests-endpoint\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"tier1-grpc":{"containerPort":"{{ if (index $config \"substreams-tier1-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"substreams-tier1-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"},"tier1-subreq":{"containerPort":"{{ if (index $config \"substreams-tier1-subrequests-endpoint\") }}{{ splitList \":\" (index $config \"substreams-tier1-subrequests-endpoint\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}},"resources":{"limits":{"cpu":4,"memory":"18Gi"},"requests":{"cpu":4,"memory":"18Gi"}}}}}}}}},"substreams-tier2":{"fireeth":{"config":{"substreams-tier2-grpc-listen-addr":":10018","substreams-tier2-max-concurrent-requests":4}},"services":{"default":{"__enabled":true,"spec":{"ports":{"tier2-grpc":{"port":"{{ if (index $config \"substreams-tier2-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"substreams-tier2-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"tier1-grpc":{"port":"{{ if (index $config \"substreams-tier1-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"substreams-tier1-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"},"tier1-subreq":{"port":"{{ if (index $config \"substreams-tier1-subrequests-endpoint\") }}{{ splitList \":\" (index $config \"substreams-tier1-subrequests-endpoint\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"tier2-grpc":{"containerPort":"{{ if (index $config \"substreams-tier2-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"substreams-tier2-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}},"resources":{"limits":{"cpu":4,"memory":"18Gi"},"requests":{"cpu":4,"memory":"18Gi"}}}}}}}}}}` |
 | firehoseServiceDefaults.firehose | Defaults for the firehose service | object | `{"fireeth":{"config":{"firehose-grpc-listen-addr":"0.0.0.0:10015"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"fh-grpc":{"port":"{{ if (index $config \"firehose-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"firehose-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"fh-grpc":{"containerPort":"{{ if (index $config \"firehose-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"firehose-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n"}}}}}}}}}` |
 | firehoseServiceDefaults.index-builder | Defaults for the index-builder service | object | `{"fireeth":{"config":{"index-builder-grpc-listen-addr":"0.0.0.0:10009","index-builder-index-size":"1000"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"index-grpc":{"port":"{{ if (index $config \"index-builder-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"index-builder-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"index-grpc":{"port":"{{ if (index $config \"index-builder-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"index-builder-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"index-grpc":{"containerPort":"{{ with .Self.fireeth.config }}{{ if (index . \"index-builder-grpc-listen-addr\") }}{{ splitList \":\" (index . \"index-builder-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}{{ end }}","protocol":"TCP"}}}}}}}}}` |
 | firehoseServiceDefaults.merger | Defaults for the merger service | object | `{"fireeth":{"config":{"merger-grpc-listen-addr":":10012"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"merger-grpc":{"port":"{{ if (index $config \"merger-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"merger-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"merger-grpc":{"port":"{{ if (index $config \"merger-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"merger-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"merger-grpc":{"containerPort":"{{ if (index $config \"merger-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"merger-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }}\n@needs(.Self.fireeth.config as config)\n","protocol":"TCP"}}}}}}}}}` |
 | firehoseServiceDefaults.reader-node | Defaults for the reader-node service | object | `{"clusterRole":{"__enabled":"{{ $p2pEnabled }} @needs(.Self.fireeth.p2p.enabled as p2pEnabled)","rules":[{"apiGroups":[""],"resources":["nodes"],"verbs":["get","list","watch"]}]},"configMap":{"__enabled":true,"__options":{"useEnvSubst":true},"data":{"genesis.json":"{{ $genesisJson.enabled \| ternary ( $genesisJson.data \| toYaml \| nindent 8 ) nil }} @needs(.Self.fireeth[genesis-json] as genesisJson)\n"}},"fireeth":{"config":{"reader-node-bootstrap-data-url":"{{ $genesisJson.enabled \| ternary \"/genesis/genesis.json\" nil }} @needs(.Self.fireeth[genesis-json] as genesisJson)","reader-node-data-dir":"/var/lib/geth","reader-node-grpc-listen-addr":"0.0.0.0:10010","reader-node-manager-api-addr":"127.0.0.1:10011","reader-node-path":"/app/geth"},"genesis-json":{"data":{"genesis.json":"<JSON data>\n"},"enabled":false},"jwt":{"enabled":true},"nodeArgs":{"__prefix":"--","__separator":"=","authrpc.addr":"0.0.0.0","authrpc.jwtsecret":"{{ $jwt.enabled \| ternary \"/secrets/jwt/jwt.hex\" nil }} @needs(.Self.fireeth.jwt as jwt)","authrpc.port":8551,"authrpc.vhosts":"*","cache":8192,"datadir":"{node-data-dir}","discovery.port":"{{ $p2p.enabled \| ternary \"${EXTERNAL_PORT_P2P_TCP}\" nil }} @needs(.Self.fireeth.p2p as p2p)","history.transactions":1000,"http":"__none","http.addr":"0.0.0.0","http.api":"net,web3,eth,debug","http.port":8545,"http.vhosts":"*","maxpeers":100,"metrics.addr":"{{ $nodeMetrics.enabled \| ternary $nodeMetrics.addr nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","metrics.port":"{{ $nodeMetrics.enabled \| ternary ($nodeMetrics.port \| int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","nat":"{{ $p2p.enabled \| ternary \"extip:${EXTERNAL_IP}\" nil }} @needs(.Self.fireeth.p2p as p2p)","port":"{{ $p2p.enabled \| ternary \"${EXTERNAL_PORT_P2P_TCP}\" nil }} @needs(.Self.fireeth.p2p as p2p)","snapshot":"true","syncmode":"full","vmtrace":"firehose"},"nodeArgsOrder":[],"nodeMetrics":{"addr":"0.0.0.0","enabled":true,"port":6061},"p2p":{"enabled":true,"port":null}},"role":{"__enabled":true,"rules":[{"apiGroups":[""],"resources":["services"],"verbs":["get","list","watch"]},{"apiGroups":[""],"resources":["secrets"],"verbs":["get","create"]}]},"services":{"default":{"spec":{"ports":{"node-authrpc":{"port":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary (index $nodeArgs \"authrpc.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"node-metrics":{"port":"{{ $nodeMetrics.enabled \| ternary ($nodeMetrics.port \| int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","protocol":"{{ $nodeMetrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)"},"node-mgr":{"port":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary (splitList \":\" (index $config \"reader-node-manager-api-addr\") \| last) nil }} @needs(.Self.fireeth.config as config)","protocol":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.config as config)"},"node-rpc":{"port":"{{ hasKey $nodeArgs \"http.port\" \| ternary (index $nodeArgs \"http.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"http.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"reader-grpc":{"port":"{{ if (index $config \"reader-node-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"reader-node-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"spec":{"ports":{"node-authrpc":{"port":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary (index $nodeArgs \"authrpc.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"node-metrics":{"port":"{{ $nodeMetrics.enabled \| ternary ($nodeMetrics.port \| int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","protocol":"{{ $nodeMetrics.enabled \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)"},"node-mgr":{"port":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary (splitList \":\" (index $config \"reader-node-manager-api-addr\") \| last) nil }} @needs(.Self.fireeth.config as config)","protocol":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.config as config)"},"node-rpc":{"port":"{{ hasKey $nodeArgs \"http.port\" \| ternary (index $nodeArgs \"http.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"{{ hasKey $nodeArgs \"http.port\" \| ternary \"TCP\" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)"},"reader-grpc":{"port":"{{ if (index $config \"reader-node-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"reader-node-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"kind":"StatefulSet","spec":{"serviceName":"{{ include \"common.metadata.fullname\" $ }}-{{ .componentName }}-headless","template":{"spec":{"containers":{"fireeth":{"env":{"MANAGER_API_PORT":{"value":"{{ hasKey $config \"reader-node-manager-api-addr\" \| ternary (splitList \":\" (index $config \"reader-node-manager-api-addr\") \| last \| trimSuffix \"*\" \| int) nil }}\n@type(string)\n@needs(.Self.fireeth.config as config)\n"}},"lifecycle":{"preStop":{"exec":{"command":["/usr/local/bin/eth-maintenance"]}}},"ports":{"node-authrpc":{"containerPort":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary (index $nodeArgs \"authrpc.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"TCP"},"node-metrics":{"containerPort":"{{ if $nodeMetrics.port }}{{ $nodeMetrics.port \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","protocol":"TCP"},"node-mgr":{"containerPort":"{{ splitList \":\" ( index $config \"reader-node-manager-api-addr\" ) \| last \| int }} @needs(.Self.fireeth.config as config)","protocol":"TCP"},"node-rpc":{"containerPort":"{{ hasKey $nodeArgs \"http.port\" \| ternary (index $nodeArgs \"http.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"TCP"},"reader-grpc":{"containerPort":"{{ if (index $config \"reader-node-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"reader-node-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}},"volumeMounts":{"genesis-json":{"__enabled":"{{ $genesisJson.enabled \| default false }} @needs(.Self.fireeth[genesis-json] as genesisJson)","mountPath":"/genesis","readOnly":true,"subPath":"genesis.json"},"jwt-secret":{"__enabled":"{{ $jwt.enabled \| default false }} @needs(.Self.fireeth.jwt as jwt)","mountPath":"/secrets/jwt","readOnly":true},"node-data-dir":{"__enabled":true,"mountPath":"{{ index $config \"reader-node-data-dir\" }} @needs(.Self.fireeth.config as config)","readOnly":false}}}},"volumes":{"data-dir":{"emptyDir":null,"persistentVolumeClaim":{"claimName":"data-dir"}},"genesis-json":{"__enabled":"{{ $genesisJson.enabled \| default false }} @needs(.Self.fireeth[genesis-json] as genesisJson)","configMap":{"defaultMode":420,"items":[{"key":"genesis.json","path":"genesis.json"}],"name":"{{ $configMapName }} @needs(.Self.configMap.metadata.name as configMapName)"}},"jwt-secret":{"__enabled":"{{ .Self.fireeth.jwt.enabled \| default false }}","secret":{"items":[{"key":"{{ with .Self.fireeth.jwt }}{{ .existingSecret.key \| default \"jwt.hex\" }}{{ end }}","path":"jwt.hex"}],"secretName":"{{ with .Self.fireeth.jwt }}{{ .existingSecret.name \| default (printf \"%s-%s-jwt\" (include \"common.metadata.fullname\" $) $.componentName ) }}{{ end }}"}},"node-data-dir":{"__enabled":true,"persistentVolumeClaim":{"claimName":"node-data-dir"}}}}},"volumeClaimTemplates":{"data-dir":{"__enabled":true,"metadata":{"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"data-dir"},"spec":{"accessModes":["ReadWriteOnce"],"resources":{"requests":{"storage":"50Gi"}},"storageClassName":"openebs-zfs-localpv-compressed-8k"}},"node-data-dir":{"__enabled":true,"metadata":{"labels":"{{ $globalLabels \| toYaml }}\n@needs(.Root.Values.global.labels as globalLabels)\n@type(yaml)","name":"node-data-dir"},"spec":{"accessModes":["ReadWriteOnce"],"resources":{"requests":{"storage":"3Ti"}},"storageClassName":"openebs-zfs-localpv-compressed-8k"}}}}}}` |
 | firehoseServiceDefaults.reader-node.fireeth.genesis-json.data."genesis.json" | Add your genesis file JSON here | string | `"<JSON data>\n"` |
 | firehoseServiceDefaults.reader-node.fireeth.genesis-json.enabled | Add a genesis.json key to reader-node configMap | bool | `false` |
 | firehoseServiceDefaults.reader-node.workload.spec.template.spec.containers.fireeth.ports | Container ports | object | `{"node-authrpc":{"containerPort":"{{ hasKey $nodeArgs \"authrpc.port\" \| ternary (index $nodeArgs \"authrpc.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"TCP"},"node-metrics":{"containerPort":"{{ if $nodeMetrics.port }}{{ $nodeMetrics.port \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)","protocol":"TCP"},"node-mgr":{"containerPort":"{{ splitList \":\" ( index $config \"reader-node-manager-api-addr\" ) \| last \| int }} @needs(.Self.fireeth.config as config)","protocol":"TCP"},"node-rpc":{"containerPort":"{{ hasKey $nodeArgs \"http.port\" \| ternary (index $nodeArgs \"http.port\" \| int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)","protocol":"TCP"},"reader-grpc":{"containerPort":"{{ if (index $config \"reader-node-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"reader-node-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}` |
 | firehoseServiceDefaults.relayer | Defaults for the relayer service | object | `{"fireeth":{"config":{"relayer-grpc-listen-addr":"0.0.0.0:10014","relayer-max-source-latency":"1h","relayer-source":"firehose-ethereum-1-reader:10010"}},"services":{"default":{"__enabled":true,"spec":{"ports":{"relayer-grpc":{"port":"{{ if (index $config \"relayer-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"relayer-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}},"headless":{"<<":{"__enabled":true,"spec":{"ports":{"relayer-grpc":{"port":"{{ if (index $config \"relayer-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"relayer-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}},"workload":{"spec":{"template":{"spec":{"containers":{"fireeth":{"ports":{"relayer-grpc":{"containerPort":"{{ if (index $config \"relayer-grpc-listen-addr\") }}{{ splitList \":\" (index $config \"relayer-grpc-listen-addr\") \| last \| trimSuffix \"*\" \| int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)","protocol":"TCP"}}}}}}}}}` |
 | global.annotations | Global annotations added to all resources | object | `{}` |
 | global.fullnameOverride |  | string | `""` |
 | global.labels | Global labels added to all resources | object | `{"app.kubernetes.io/component":"{{ .componentName }}","app.kubernetes.io/instance":"{{ .Root.Release.Name }}","app.kubernetes.io/managed-by":"{{ .Root.Release.Service }}","app.kubernetes.io/name":"{{ .Root.Chart.Name }}","app.kubernetes.io/part-of":"{{ .Root.Release.Name }}","app.kubernetes.io/version":"{{ .Root.Chart.AppVersion }}","helm.sh/chart":"{{ include \"common.metadata.chart\" . }}","version.firehose.graphops.xyz/fireeth":"2.11.1","version.firehose.graphops.xyz/node":"1.15.5","version.firehose.graphops.xyz/protocol":"3.0"}` |
 | global.nameOverride |  | string | `""` |

## Contributing

We welcome and appreciate your contributions! Please see the [Contributor Guide](/CONTRIBUTING.md), [Code Of Conduct](/CODE_OF_CONDUCT.md) and [Security Notes](/SECURITY.md) for this repository.
