# Default values for firehose-ethereum.
# This is a YAML-formatted file.

global:
  nameOverride: ""
  fullnameOverride: ""
  # -- Global labels added to all resources
  labels:
    helm.sh/chart: '{{ include "common.metadata.chart" . }}'
    app.kubernetes.io/name: '{{ .Root.Chart.Name }}'
    app.kubernetes.io/instance: '{{ .Root.Release.Name }}'
    app.kubernetes.io/version: '{{ .Root.Chart.AppVersion }}'
    app.kubernetes.io/managed-by: '{{ .Root.Release.Service }}'
    app.kubernetes.io/component: '{{ .componentName }}'
    app.kubernetes.io/part-of: '{{ .Root.Release.Name }}'
    version.firehose.graphops.xyz/fireeth: "2.11.1"
    version.firehose.graphops.xyz/node: "1.15.5"
    version.firehose.graphops.xyz/protocol: "3.0"
  # -- Global annotations added to all resources
  annotations: {}

firehoseComponentDefaults:
  __enabled: true
  #FIXME: image special config?
  # -- Image configuration for firehose-ethereum
  image:
    # -- Docker image repository
    repository: "ghcr.io/streamingfast/firehose-ethereum"
    # -- Image pull policy
    pullPolicy: "IfNotPresent"
    # -- Overrides the image reference using a tag
    # digest takes precedence over tag if both are set
    tag: "v2.11.1-geth-v1.15.5-fh3.0 "
    # -- Overrides the image reference using a specific digest
    digest: ""

  # -- Pull secrets required to fetch images
  imagePullSecrets: []

  # -- Firehose-specific configuration
  fireeth:
    # -- List of firehose services to launch (reader-node | merger | relayer | ...)
    services: []

    # -- Enable support for metrics
    metrics:
      enabled: true
      addr: 0.0.0.0
      port: 9102

    # -- Enable pprof interface support for profiling data
    pprof:
      enabled: true
      addr: 127.0.0.1
      port: 6060

    # -- Enable a NodePort for P2P support in node
    p2p:
      # -- Expose P2P port via NodePort
      enabled: false
      # -- NodePort to be used. Must be unique.
      # Leave blank for a dynamic port
      port: null

    # -- Provision or use an existing JWT secret
    # If it's enabled and neither existingSecret
    # nor fromLiteral are set, a random secret will
    # be generated and then re-used in the future
    jwt:
      # -- Provision or make use of a JWT secret for Node
      enabled: false
      # -- Load the JWT from an existing Kubernetes Secret. Takes precedence over `fromLiteral` if set.
      existingSecret:
        # -- Name of the Secret resource in the same namespace
        name: null
        # -- Data key for the JWT in the Secret
        key: null
      # -- Use this literal value for the JWT
      fromLiteral: null

    genesis-json:
      # -- Add a genesis.json key to configMap
      enabled: false
      # -- Add your genesis file JSON here
      # data: |

    # -- Fireeth configuration paramaters
    config:
      data-dir: "/var/lib/fireeth"
      metrics-listen-addr: |
        {{ $metrics.enabled | ternary (printf "%s:%d" $metrics.addr ( $metrics.port | int ) ) nil }}
        @needs(.Self.fireeth.metrics as metrics)
      pprof-listen-addr: '{{ $pprof.enabled | ternary (printf "%s:%d" $pprof.addr ($pprof.port | int)) nil }} @needs(.Self.fireeth.pprof as pprof)'
      log-to-file: false
      firehose-rate-limit-bucket-size: 20
      firehose-rate-limit-bucket-fill-rate: "1s"
      common-one-block-store-url: null
      common-forked-blocks-store-url: null
      common-merged-blocks-store-url: null
      common-live-blocks-addr: "relayer:10014"
      common-auto-mem-limit-percent: 95
      common-auto-max-procs: true
      common-auth-plugin: null://
      substreams-block-execution-timeout: 3m0s
      substreams-rpc-endpoints: null
      substreams-rpc-gas-limit: "50000000"
      substreams-state-bundle-size: 1000
      substreams-state-store-default-tag: ""
      substreams-state-store-url: null

    # -- Command line arguments for fireeth
    # Generated from this map and format can be
    # tweaked with __separator and __prefix.
    # the '__none' string allows for declaring
    # an argument without a value (i.e. --sepolia)
    args:
      __separator: "="
      start: "__none"
      "--config-file": "/config/config.yaml"
    # -- List to set a specific order for some of
    # the args elements. The ones set will appear first
    # in the order of the list, and the reamining ones
    # will be unsorted, or alphabetically sorted
    argsOrder:
      - start
      - "--config-file"

    # -- Enable support for metrics on the blockchain node
    nodeMetrics:
      enabled: false

    # -- Command line arguments to pass to the blockchain node
    nodeArgs: {}

    # -- List or ordered arguments for the nodeArgs
    nodeArgsOrder: []

  #####   Resources  Section   #####
  ##################################

  # -- ConfigMap customization
  configMap:
    # -- Create a ConfigMap (highly recommended)
    __enabled: true
    # -- ConfigMap specific options
    __options:
      # -- Run an envsubst initcontainer at runtime
      useEnvSubst: false
      # -- Default ConfigMap template for the fireeth config
    # -- Any remaiing key/values can be added and will be
    # merged with the templated ConfigMap resource
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
      name: '{{ .Root.Release.Name }}-{{ .componentName }}-config'
    data:
      config.yaml: |-
        {{- $hasServiceNode := false }}
        start:
          args:
            {{- range $services }}
            - {{ . }}
            {{- if (contains "node" .) }}
            {{- $hasServiceNode = true }}
            {{- end }}
            {{- end }}
          flags:
            {{- range $key, $value := $config }}
            {{ $key }}: "{{ $value }}"
            {{- end }}
            {{- if $hasServiceNode }}
            {{- $readerNodeArgs := include "common.utils.generateArgsList" (dict "map" ( $nodeArgs | default dict ) "orderList" ( $nodeArgsOrder | default list ) ) | fromYamlArray }}
            reader-node-arguments: |
              {{- range $readerNodeArgs }}
              {{ . }}
              {{- end }}
              {{- end }}
        @needs(.Self.fireeth.services as services)
        @needs(.Self.fireeth.config as config)
        @needs(.Self.fireeth.nodeArgs as nodeArgs)
        @needs(.Self.fireeth.nodeArgsOrder as nodeArgsOrder)

  # -- Service customization
  services:
    default:
      # -- Create a Service
      __enabled: true
      # -- Any other key/values will be merged with the final Service resource
      # `spec.ports` is a key-value map, with the port name as key, and the spec as value
      spec: &defaultServiceSpec
        # -- Service type
        type: "ClusterIP"
        # -- Service ports configuration
        ports:
          fh-metrics:
            port: '{{ $metrics.enabled | ternary (printf "%d" ( $metrics.port | int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)'
            protocol: '{{ $metrics.enabled | ternary "TCP" nil }} @needs(.Self.fireeth.metrics as metrics)'
          fh-pprof:
            port: '{{ $pprof.enabled | ternary (printf "%d" ( $pprof.port | int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)'
            protocol: '{{ $pprof.enabled | ternary "TCP" nil }} @needs(.Self.fireeth.pprof as pprof)'
        selector:
          app.kubernetes.io/component: '{{ .componentName }}'
          app.kubernetes.io/instance: '{{ .Root.Release.Name }}'
          app.kubernetes.io/name: '{{ .Root.Chart.Name }}'
      metadata:
        name: '{{ include "common.metadata.fullname" $ }}-{{ .componentName }}'
        # -- Additional service labels
        labels: |-
          {{ $globalLabels | toYaml }}
          @needs(.Root.Values.global.labels as globalLabels)
          @type(yaml)
        # -- Additional service annotations
        annotations: {}
    headless:
      # -- Create headless services, mandatory for StatefulSets and true by default
      __enabled: '{{ eq $kind "StatefulSet" | ternary true true }} @needs(.Self.workload.kind as kind)'
      # -- Any other key/values will be merged with the final Service resource
      # `spec.ports` is a key-value map, with the port name as key, and the spec as value
      spec:
        <<: *defaultServiceSpec
        clusterIP: None
      metadata:
        name: '{{ include "common.metadata.fullname" $ }}-{{ .componentName }}-headless'
        # -- Additional service labels
        labels: |-
          {{ $globalLabels | toYaml }}
          @needs(.Root.Values.global.labels as globalLabels)
          @type(yaml)
        # -- Additional service annotations
        annotations: {}
    # -- Creates a NodePort service (used in P2P support)
    # if a nodePort isn't specified, kubernetes will dinamically attribute one
    p2p:
      __enabled: '{{ default false $p2p.enabled }} @needs(.Self.fireeth.p2p as p2p)'
      # -- Any other key/values will be merged with the final Service resource
      # `spec.ports` is a key-value map, with the port name as key, and the spec as value
      spec:
        type: NodePort
        # -- Service ports configuration
        ports:
          p2p-tcp:
            # -- (mandatory) default is to use nodePort if specified, or 30303
            port: '{{ default (30303 | int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)'
            # -- (optional) default is to use the port's name
            targetPort: null
            # -- (optional) nodePort to use, if left null a dynamic one will be atributed
            nodePort: null
            protocol: TCP
          p2p-udp:
            # -- (mandatory) default is to use nodePort if specified, or 30303
            port: '{{ default (30303 | int) $p2p.port }} @needs(.Self.fireeth.p2p as p2p)'
            # -- (optional) default is to use the port's name
            targetPort: null
            # -- (optional) nodePort to use, if left null a dynamic one will be atributed
            nodePort: null
            protocol: UDP
        selector:
          app.kubernetes.io/component: '{{ .componentName }}'
          app.kubernetes.io/instance: '{{ .Root.Release.Name }}'
          app.kubernetes.io/name: '{{ .Root.Chart.Name }}'
      metadata:
        name: '{{ include "common.metadata.fullname" $ }}-{{ .componentName }}-p2p'
        # -- Additional service labels
        labels: |-
          type: p2p
          pod: '{{ include "common.metadata.fullname" $ }}-{{ .componentName }}-0'
          {{ $globalLabels | toYaml }}
          @needs(.Root.Values.global.labels as globalLabels)
          @type(yaml)
        # -- Additional service annotations
        annotations: {}

  # -- Required for StatefulSets
  serviceName: '{{ include "common.metadata.fullname" $ }}-{{ .componentName }}-headless'

  # -- ServiceMonitor configuration for Prometheus Operator
  serviceMonitor:
    # -- Enable monitoring by creating `ServiceMonitor` CRDs ([prometheus-operator](https://github.com/prometheus-operator/prometheus-operator))
    __enabled: true
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
      name: '{{ printf "%s-%s" (include "common.metadata.fullname" $) .componentName }}'
    spec:
      # Endpoint overrides, keyed by port name
      endpoints:
        fh-metrics:
          # Override or add any endpoint-specific fields
          interval: "30s"
          scrapeTimeout: "10s"
          path: /metrics
          honorLabels: true
          # ... any other endpoint-specific fields
      # Any other top-level ServiceMonitor spec fields
      jobLabel: '{{- .Root.Release.Name }}'
      selector:
        matchLabels:
          app.kubernetes.io/component: '{{ .componentName }}'
          app.kubernetes.io/instance: '{{ .Root.Release.Name }}'
          app.kubernetes.io/name: '{{ .Root.Chart.Name }}'

  # -- Service account configuration
  serviceAccount:
    # -- Specifies whether a service account should be created
    __enabled: true
    # -- Rest spec
    metadata:
      # -- The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: '{{ printf "%s-%s" (include "common.metadata.fullname" $) .componentName }}'
      # -- Annotations to add to the service account
      annotations: {}
      # -- Labels to add to the service account
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
    # secrets: []

  # -- RBAC role and binding configuration
  role:
    __enabled: '{{ $SAEnabled }} @needs(.Self.serviceAccount.__enabled as SAEnabled)'
    __name: "role"
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
      name: '{{ printf "%s-%s-%s" .Root.Release.Name .componentName $roleName }} @needs(.Self.role.__name as roleName)'
    rules: []

  roleBinding:
    __enabled: '{{ $roleEnabled }} @needs(.Self.role.__enabled as roleEnabled)'
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
      name: '{{ printf "%s-%s-%s" .Root.Release.Name .componentName $roleName }} @needs(.Self.role.__name as roleName)'
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: Role
      name: '{{ $roleName }} @needs(.Self.role.metadata.name as roleName)'
    subjects:
      - kind: ServiceAccount
        name: '{{ $SAName }} @needs(.Self.serviceAccount.metadata.name as SAName)'
        namespace: '{{ .Root.Release.Namespace }}'

  # -- Cluster scoped RBAC role and binding configuration
  # Used by the P2P init-container
  clusterRole:
    __enabled: false
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
      name: my-cluster-role
    rules: []

  clusterRoleBinding:
    __enabled: false
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
      name: '{{ print "%s-binding" $roleName }} @needs(.Self.clusterRole.metadata.name as roleName)'
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: '{{ $roleName }} @needs(.Self.clusterRole.metadata.name as roleName)'
    subjects:
      default:
        kind: ServiceAccount
        name: '{{ $SAName }} @needs(.Self.serviceAccount.metadata.name as SAName)'
        namespace: '{{ .Root.Release.Namespace }}'

  # --.Self.Disruption Budget configuration
  podDisruptionBudget:
    __enabled: true
    spec:
      # minAvailable: 1
      # or
      # maxUnavailable: 25%
      selector:
        matchLabels:
          app.kubernetes.io/component: '{{ .componentName }}'
          app.kubernetes.io/instance: '{{ .Root.Release.Name }}'
          app.kubernetes.io/name: '{{ .Root.Chart.Name }}'
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
      name: '{{ .Root.Release.Name }}-{{ .componentName }}'

  # -- HorizontalPodAutoscaler configuration
  horizontalPodAutoscaler:
    __enabled: false
    # -- Anything else will be marge on the final horizonta.Self.utoscaler resource template
    metadata:
      labels: |-
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      annotations: {}
    spec: {}
      # example:
      # minReplicas: 2
      # maxReplicas: 10
      # metrics:
      #   - type: "Resource"
      #     resource:
      #       name: "cpu"
      #       targetAverageUtilization: 80


  workload:
    __enabled: true
    # -- Default workload type (Deployment | StatefulSet)
    kind: Deployment
    metadata:
      # -- Component level annotations (templated)
      annotations: {}
      # -- Component level labels (templated)
      labels: |-
        app.kubernetes.io/component: '{{ .componentName }}'
        app.kubernetes.io/part-of: '{{ .Root.Release.Name }}'
        {{ $globalLabels | toYaml }}
        @needs(.Root.Values.global.labels as globalLabels)
        @type(yaml)
      name: '{{ printf "%s-%s" (include "common.metadata.fullname" $) .componentName }}'
    spec:
      selector:
        matchLabels:
          app.kubernetes.io/component: '{{ .componentName }}'
          app.kubernetes.io/instance: '{{ .Root.Release.Name }}'
          app.kubernetes.io/name: '{{ .Root.Chart.Name }}'
      # -- (StatefulSet only), scaling behavior: (OrderedReady | Parallel)
      podManagementPolicy: '{{ eq $kind "StatefulSet" | ternary "OrderedReady" nil }} @needs(.Self.workload.kind as kind)'
      # -- Update Strategy, (RollingUpdate | Recreate) for Deployments, (RollingUpdate | OnDelete) for StatefulSets
      updateStrategy:
        __enabled: '{{- eq $kind "StatefulSet" }} @needs(.Self.workload.kind as kind)'
        type: RollingUpdate
      template:
        metadata:
          labels: |-
            {{ $globalLabels | toYaml }}
            @needs(.Root.Values.global.labels as globalLabels)
            @type(yaml)
        spec:
          serviceAccountName: '{{ $sa.__enabled | ternary $sa.metadata.name nil }} @needs(.Self.serviceAccount as sa)'
          # Increasing the grace termination period prevents Kubernetes
          # from killing the node process prematurely. Premature shutdown
          # can lead to data integrity issues
          # -- Amount of time to wait before force-killing the process
          terminationGracePeriodSeconds: 10
          # --.Self.wide security context
          securityContext:
            runAsNonRoot: true
            runAsUser: 1000
            runAsGroup: '{{ $runAsUser }} @needs(.Self.workload.spec.template.spec.securityContext.runAsUser as runAsUser)'
            fsGroup: '{{ $runAsUser }} @needs(.Self.workload.spec.template.spec.securityContext.runAsUser as runAsUser)'
          # -- Node selector configuration
          nodeSelector: {}
          # -- Tolerations configuration
          tolerations: []
          # -- Affinity configuration
          affinity: {}
          # -- Topology spread constraints
          topologySpreadConstraints: []
          # --.Self.volumes
          volumes:
            data-dir:
              __enabled: true
              emptyDir: {}
            config:
              __enabled: '{{ $configMapEnabled }} @needs(.Self.configMap.__enabled as configMapEnabled)'
              configMap:
                name: '{{ $configMapName }} @needs(.Self.configMap.metadata.name as configMapName)'
                defaultMode: 420
            config-processed:
              __enabled: '{{ and $configMap.__options.useEnvSubst $configMap.__enabled }} @needs(.Self.configMap as configMap)'
              emptyDir:
                medium: Memory
            env-dir:
              __enabled: '{{ (or (and $configMap.__options.useEnvSubst $configMap.__enabled) false ) | ternary true false }} @needs(.Self.configMap as configMap)'
              emptyDir:
                medium: Memory
          containers:
            fireeth:
              image: '{{ printf "%s:%s" $repository $tag }} @needs(.Self.image.repository as repository) @needs(.Self.image.tag as tag)'
              imagePullPolicy: IfNotPresent
              # -- Container entrypoint
              command:
                - /app/fireeth
              args: |
                {{- $argsList := include "common.utils.generateArgsList" (dict "map" ( $args | default dict ) "orderList" ( $argsOrder | default list ) ) | fromYamlArray }}
                {{ $argsList | toYaml }}
                @needs(.Self.fireeth.args as args)
                @needs(.Self.fireeth.argsOrder as argsOrder)
                @type(yamlArray)
              # -- Container level ports configuration
              ports:
                fh-metrics:
                  containerPort: '{{ $metrics.enabled | ternary (printf "%d" ( $metrics.port | int ) ) nil }} @needs(.Self.fireeth.metrics as metrics)'
                  protocol: TCP
                fh-pprof:
                  containerPort: '{{ $pprof.enabled | ternary (printf "%d" ( $pprof.port | int ) ) nil }} @needs(.Self.fireeth.pprof as pprof)'
                  protocol: TCP
              # -- Container volumeMounts
              volumeMounts:
                data-dir:
                  __enabled: true
                  readOnly: false
                  mountPath: '{{ index $config "data-dir" }} @needs(.Self.fireeth.config as config)'
                config:
                  __enabled: '{{ $configMapEnabled }} @needs(.Self.configMap.__enabled as configMapEnabled)'
                  mountPath: '{{ $useEnvSubst | ternary "/config-input" "/config" }} @needs(.Self.configMap.__options.useEnvSubst as useEnvSubst)'
                  readOnly: true
                config-processed:
                  __enabled: '{{ $useEnvSubst }} @needs(.Self.configMap.__options.useEnvSubst as useEnvSubst)'
                  mountPath: "/config"
                  readOnly: false
              # -- Environment variables
              env:
                POD_NAME:
                  valueFrom:
                    fieldRef:
                      fieldPath: metadata.name
              # -- Container level security context overrides
              securityContext:
                allowPrivilegeEscalation: false
                readOnlyRootFilesystem: true
                capabilities:
                  drop:
                    - ALL
              # -- Resource requests and limits
              resources: {}
                # We usually recommend not to specify default resources and to leave this as a conscious
                # choice for the user. This also increases chances charts run on environments with little
                # resources, such as Minikube. If you do want to specify resources, uncomment the following
                # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
                # limits:
                #   cpu: 100m
                #   memory: 128Mi
                #   ephemeral-storage: 100Mi
                # requests:
                #   cpu: 100m
                #   memory: 128Mi
                #   ephemeral-storage: 100Mi
              # -- Lifecycle hooks
              lifecycle: {}
          # -- Init containers configuration
          initContainers:
            10-init-nodeport@common:
              __enabled: '{{ $p2p.enabled }} @needs(.Self.fireeth.p2p as p2p)'
              image: ghcr.io/graphops/docker-builds/init-toolbox:main
              imagePullPolicy: IfNotPresent
              resources: {}
            20-init-envsubst@common:
              __enabled: '{{ $configMapOpt.useEnvSubst }} @needs(.Self.configMap.__options as configMapOpt)'
              image: blockstack/envsubst:latest
              imagePullPolicy: IfNotPresent
              resources: {}

# -- Defaults per firehose service type, will
# get inherited by workloads running that service
# keys will match service names, and on each key
# the same interface as <firehoseDefaults> is available
firehoseServiceDefaults:
  # -- Defaults for the firehose service
  firehose:
    fireeth:
      config:
        firehose-grpc-listen-addr: "0.0.0.0:10015"

    services:
      default:
        __enabled: true
        spec:
          ports:
            fh-grpc:
              port: |
                {{ if (index $config "firehose-grpc-listen-addr") }}{{ splitList ":" (index $config "firehose-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }}
                @needs(.Self.fireeth.config as config)
              protocol: TCP
    workload:
      spec:
        template:
          spec:
            containers:
              fireeth:
                ports:
                  fh-grpc:
                    containerPort: |
                      {{ if (index $config "firehose-grpc-listen-addr") }}{{ splitList ":" (index $config "firehose-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }}
                      @needs(.Self.fireeth.config as config)

  # -- Defaults for the merger service
  merger:
    fireeth:
      config:
        merger-grpc-listen-addr: ":10012"

    services:
      default: &mergerSvc
        __enabled: true
        spec:
          ports:
            merger-grpc:
              port: |
                {{ if (index $config "merger-grpc-listen-addr") }}{{ splitList ":" (index $config "merger-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }}
                @needs(.Self.fireeth.config as config)
              protocol: TCP
      headless:
        <<: *mergerSvc

    workload:
      spec:
        template:
          spec:
            containers:
              fireeth:
                ports:
                  merger-grpc:
                    containerPort: |
                      {{ if (index $config "merger-grpc-listen-addr") }}{{ splitList ":" (index $config "merger-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }}
                      @needs(.Self.fireeth.config as config)
                    protocol: TCP

  # -- Defaults for the relayer service
  relayer:
    fireeth:
      config:
        relayer-source: "firehose-ethereum-1-reader:10010"
        relayer-grpc-listen-addr: "0.0.0.0:10014"
        relayer-max-source-latency: 1h

    services:
      default: &relayerSvc
        __enabled: true
        spec:
          ports:
            relayer-grpc:
              port: '{{ if (index $config "relayer-grpc-listen-addr") }}{{ splitList ":" (index $config "relayer-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
              protocol: TCP
      headless:
        <<: *relayerSvc

    workload:
      spec:
        template:
          spec:
            containers:
              fireeth:
                ports:
                  relayer-grpc:
                    containerPort: '{{ if (index $config "relayer-grpc-listen-addr") }}{{ splitList ":" (index $config "relayer-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
                    protocol: TCP

  # -- Defaults for the index-builder service
  index-builder:
    fireeth:
      config:
        index-builder-grpc-listen-addr: "0.0.0.0:10009"
        index-builder-index-size: "1000"

    services:
      default: &indexSvc
        __enabled: true
        spec:
          ports:
            index-grpc:
              port: '{{ if (index $config "index-builder-grpc-listen-addr") }}{{ splitList ":" (index $config "index-builder-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
              protocol: TCP
      headless:
        <<: *indexSvc

    workload:
      spec:
        template:
          spec:
            containers:
              fireeth:
                ports:
                  index-grpc:
                    containerPort: '{{ with .Self.fireeth.config }}{{ if (index . "index-builder-grpc-listen-addr") }}{{ splitList ":" (index . "index-builder-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }}{{ end }}'
                    protocol: TCP

  # -- Defaults for the reader-node service
  reader-node:
    fireeth:
      jwt:
        enabled: true

      p2p:
        enabled: true
        port: null

      genesis-json:
        # -- Add a genesis.json key to reader-node configMap
        enabled: false
        data:
          # -- Add your genesis file JSON here
          genesis.json: |
            <JSON data>

      config:
        reader-node-grpc-listen-addr: "0.0.0.0:10010"
        reader-node-manager-api-addr: "127.0.0.1:10011"
        reader-node-data-dir: "/var/lib/geth"
        reader-node-path: "/app/geth"
        reader-node-bootstrap-data-url: '{{ $genesisJson.enabled | ternary "/genesis/genesis.json" nil }} @needs(.Self.fireeth[genesis-json] as genesisJson)'

      nodeMetrics:
        enabled: true
        addr: 0.0.0.0
        port: 6061

      nodeArgs:
        __prefix: "--"
        __separator: "="
        datadir: "{node-data-dir}"
        vmtrace: firehose
        syncmode: "full"
        snapshot: "true"
        http: "__none"
        http.api: net,web3,eth,debug
        http.addr: 0.0.0.0
        http.port: 8545
        http.vhosts: "*"
        authrpc.addr: 0.0.0.0
        authrpc.port: 8551
        authrpc.vhosts: '*'
        history.transactions: 1000
        cache: 8192
        maxpeers: 100
        authrpc.jwtsecret: '{{ $jwt.enabled | ternary "/secrets/jwt/jwt.hex" nil }} @needs(.Self.fireeth.jwt as jwt)'
        metrics.addr: '{{ $nodeMetrics.enabled | ternary $nodeMetrics.addr nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)'
        metrics.port: '{{ $nodeMetrics.enabled | ternary ($nodeMetrics.port | int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)'
        port: '{{ $p2p.enabled | ternary "${EXTERNAL_PORT_P2P_TCP}" nil }} @needs(.Self.fireeth.p2p as p2p)'
        discovery.port: '{{ $p2p.enabled | ternary "${EXTERNAL_PORT_P2P_TCP}" nil }} @needs(.Self.fireeth.p2p as p2p)'
        nat: '{{ $p2p.enabled | ternary "extip:${EXTERNAL_IP}" nil }} @needs(.Self.fireeth.p2p as p2p)'

      nodeArgsOrder: []

    role:
      __enabled: true
      rules:
        - apiGroups: [""]
          resources:
            - "services"
          verbs:
            - "get"
            - "list"
            - "watch"
        - apiGroups: [""]
          resources:
            - "secrets"
          verbs:
            - "get"
            - "create"

    clusterRole:
      __enabled: '{{ $p2pEnabled }} @needs(.Self.fireeth.p2p.enabled as p2pEnabled)'
      rules:
        - apiGroups: [""]
          resources:
            - "nodes"
          verbs:
            - "get"
            - "list"
            - "watch"

    configMap:
      __enabled: true
      __options:
        useEnvSubst: true
      data:
        genesis.json: |
          {{ $genesisJson.enabled | ternary ( $genesisJson.data | toYaml | nindent 8 ) nil }} @needs(.Self.fireeth[genesis-json] as genesisJson)

    services:
      default: &readerSvc
        spec:
          ports:
            reader-grpc:
              port: '{{ if (index $config "reader-node-grpc-listen-addr") }}{{ splitList ":" (index $config "reader-node-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
              protocol: TCP
            node-metrics:
              port: '{{ $nodeMetrics.enabled | ternary ($nodeMetrics.port | int) nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)'
              protocol: '{{ $nodeMetrics.enabled | ternary "TCP" nil }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)'
            node-rpc:
              port: '{{ hasKey $nodeArgs "http.port" | ternary (index $nodeArgs "http.port" | int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)'
              protocol: '{{ hasKey $nodeArgs "http.port" | ternary "TCP" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)'
            node-authrpc:
              port: '{{ hasKey $nodeArgs "authrpc.port" | ternary (index $nodeArgs "authrpc.port" | int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)'
              protocol: '{{ hasKey $nodeArgs "authrpc.port" | ternary "TCP" nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)'
            node-mgr:
              port: '{{ hasKey $config "reader-node-manager-api-addr" | ternary (splitList ":" (index $config "reader-node-manager-api-addr") | last) nil }} @needs(.Self.fireeth.config as config)'
              protocol: '{{ hasKey $config "reader-node-manager-api-addr" | ternary "TCP" nil }} @needs(.Self.fireeth.config as config)'
      headless:
        <<: *readerSvc

    workload:
      kind: StatefulSet
      spec:
        serviceName: '{{ include "common.metadata.fullname" $ }}-{{ .componentName }}-headless'
        volumeClaimTemplates:
          data-dir:
            __enabled: true
            metadata:
              labels: |-
                {{ $globalLabels | toYaml }}
                @needs(.Root.Values.global.labels as globalLabels)
                @type(yaml)
              name: data-dir
            spec:
              accessModes: [ "ReadWriteOnce" ]
              storageClassName: "openebs-zfs-localpv-compressed-8k"
              resources:
                requests:
                  storage: 50Gi
          node-data-dir:
            __enabled: true
            metadata:
              labels: |-
                {{ $globalLabels | toYaml }}
                @needs(.Root.Values.global.labels as globalLabels)
                @type(yaml)
              name: node-data-dir
            spec:
              accessModes: [ "ReadWriteOnce" ]
              storageClassName: "openebs-zfs-localpv-compressed-8k"
              resources:
                requests:
                  storage: 3Ti
        template:
          spec:
            volumes:
              data-dir:
                emptyDir: null
                persistentVolumeClaim:
                  claimName: data-dir
              node-data-dir:
                __enabled: true
                persistentVolumeClaim:
                  claimName: node-data-dir
              jwt-secret:
                __enabled: '{{ .Self.fireeth.jwt.enabled | default false }}'
                secret:
                  secretName: '{{ with .Self.fireeth.jwt }}{{ .existingSecret.name | default (printf "%s-%s-jwt" (include "common.metadata.fullname" $) $.componentName ) }}{{ end }}'
                  items:
                    - key: '{{ with .Self.fireeth.jwt }}{{ .existingSecret.key | default "jwt.hex" }}{{ end }}'
                      path: "jwt.hex"
              genesis-json:
                __enabled: '{{ $genesisJson.enabled | default false }} @needs(.Self.fireeth[genesis-json] as genesisJson)'
                configMap:
                  name: '{{ $configMapName }} @needs(.Self.configMap.metadata.name as configMapName)'
                  defaultMode: 420
                  items:
                    - key: "genesis.json"
                      path: "genesis.json"
            containers:
              fireeth:
                env:
                  MANAGER_API_PORT:
                    value: |
                      {{ hasKey $config "reader-node-manager-api-addr" | ternary (splitList ":" (index $config "reader-node-manager-api-addr") | last | trimSuffix "*" | int) nil }}
                      @type(string)
                      @needs(.Self.fireeth.config as config)
                # -- Container ports
                ports:
                  reader-grpc:
                    containerPort: '{{ if (index $config "reader-node-grpc-listen-addr") }}{{ splitList ":" (index $config "reader-node-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
                    protocol: TCP
                  node-metrics:
                    containerPort: '{{ if $nodeMetrics.port }}{{ $nodeMetrics.port | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.nodeMetrics as nodeMetrics)'
                    protocol: TCP
                  node-rpc:
                    containerPort: '{{ hasKey $nodeArgs "http.port" | ternary (index $nodeArgs "http.port" | int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)'
                    protocol: TCP
                  node-authrpc:
                    containerPort: '{{ hasKey $nodeArgs "authrpc.port" | ternary (index $nodeArgs "authrpc.port" | int) nil }} @needs(.Self.fireeth.nodeArgs as nodeArgs)'
                    protocol: TCP
                  node-mgr:
                    containerPort: '{{ splitList ":" ( index $config "reader-node-manager-api-addr" ) | last | int }} @needs(.Self.fireeth.config as config)'
                    protocol: TCP

                volumeMounts:
                  node-data-dir:
                    __enabled: true
                    readOnly: false
                    mountPath: '{{ index $config "reader-node-data-dir" }} @needs(.Self.fireeth.config as config)'
                  jwt-secret:
                    __enabled: '{{ $jwt.enabled | default false }} @needs(.Self.fireeth.jwt as jwt)'
                    readOnly: true
                    mountPath: /secrets/jwt
                  genesis-json:
                    __enabled: '{{ $genesisJson.enabled | default false }} @needs(.Self.fireeth[genesis-json] as genesisJson)'
                    readOnly: true
                    mountPath: '/genesis'
                    subPath: 'genesis.json'
                lifecycle:
                  # postStart:
                  #   exec:
                  #     command: ["/bin/sh", "-c", "echo Hello from the postStart handler > /usr/share/message"]
                  # preStop:
                  #   exec:
                  #     command: ["/bin/sh","-c","nginx -s quit; while killall -0 nginx; do sleep 1; done"]
                  preStop:
                    exec:
                      command: ["/usr/local/bin/eth-maintenance"]

  substreams-tier1:
    fireeth:
      config:
        substreams-tier1-active-requests-hard-limit: 0
        substreams-tier1-active-requests-soft-limit: 4
        substreams-tier1-enforce-compression: true
        substreams-tier1-grpc-listen-addr: :10016
        substreams-tier1-max-subrequests: 4
        substreams-tier1-subrequests-endpoint: |
          {{- $port := "" }}
          {{- if (index $tier2Config "substreams-tier2-grpc-listen-addr") }}
            {{- $port = splitList ":" (index $tier2Config "substreams-tier2-grpc-listen-addr") | last | trimSuffix "*" | int }}
          {{- else }}
            {{- $port = "" }}
          {{- end }}
          {{- if not (empty $port) }}{{ printf "%s-%s:%d" .Root.Release.Name "substreams-tier2" $port }}{{ else }}null{{ end }}
          @needs(.ComponentValues.substreams-tier2.fireeth.config as tier2Config)
        substreams-tier1-subrequests-plaintext: true
    services:
      default: &tier1Svc
        __enabled: true
        spec:
          ports:
            tier1-grpc:
              port: '{{ if (index $config "substreams-tier1-grpc-listen-addr") }}{{ splitList ":" (index $config "substreams-tier1-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
              protocol: TCP
      headless:
        <<: *tier1Svc

    workload:
      spec:
        template:
          spec:
            containers:
              fireeth:
                ports:
                  tier1-grpc:
                    containerPort: '{{ if (index $config "substreams-tier1-grpc-listen-addr") }}{{ splitList ":" (index $config "substreams-tier1-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
                    protocol: TCP
                resources:
                  requests:
                    cpu: 4
                    memory: 18Gi
                  limits:
                    cpu: 4
                    memory: 18Gi
  substreams-tier2:
    fireeth:
      config:
        substreams-tier2-grpc-listen-addr: :10018
        substreams-tier2-max-concurrent-requests: 4

    services:
      default: &tier2Svc
        __enabled: true
        spec:
          ports:
            tier2-grpc:
              port: '{{ if (index $config "substreams-tier2-grpc-listen-addr") }}{{ splitList ":" (index $config "substreams-tier2-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
              protocol: TCP
      headless:
        <<: *tier2Svc
    workload:
      spec:
        template:
          spec:
            containers:
              fireeth:
                ports:
                  tier2-grpc:
                    containerPort: '{{ if (index $config "substreams-tier2-grpc-listen-addr") }}{{ splitList ":" (index $config "substreams-tier2-grpc-listen-addr") | last | trimSuffix "*" | int }}{{ else }}null{{ end }} @needs(.Self.fireeth.config as config)'
                    protocol: TCP
                resources:
                  requests:
                    cpu: 4
                    memory: 18Gi
                  limits:
                    cpu: 4
                    memory: 18Gi

# -- Definition and architecture of components to provision.
# A component is a kubernetes workload (Deployment or StatefulSet).
# The components will be named by the key name, and inherit the
# firehoseComponentDefaults as well as the defaults for the firehose
# services they will be set to run, under `.fireeth.services` list.
# For each component, configuraiton follows <firehoseComponentDefaults>.
firehoseComponents:
  grpc:
    __enabled: true
    fireeth:
      services:
        - firehose

  relayer:
    __enabled: true
    fireeth:
      services:
        - relayer

  merger:
    __enabled: true
    fireeth:
      services:
        - merger

  index-builder:
    __enabled: true
    fireeth:
      services:
        - index-builder

  reader-node:
    __enabled: true
    fireeth:
      services:
        - reader-node

  substreams-tier1:
    __enabled: true
    fireeth:
      services:
        - substreams-tier1

  substreams-tier2:
    __enabled: true
    fireeth:
      services:
        - substreams-tier2
